solutions to problems of goldman sachs

//Question 1. print all anagrams together
//solution
vector<vector<string> > Anagrams(vector<string>& string_list) {
        vector<vector<string>> ans;
        unordered_map<string,vector<string> >umap;
        for( int i=0;i<string_list.size(); i++){
            
        
        string s =string_list[i];
        sort(s.begin(),s.end());
        umap[s].push_back(string_list[i]);
        
    }
    for(auto itr=umap.begin(); itr!=umap.end();itr++)
    ans.push_back(itr->second);
    return ans;
    }
    /* 
    T(c)- O(N*|S|*log|S|) where N is the total number of strings and |S| denotes the size of string so |S|log|S| time would be taken for sorting them.
    S(c)-O(N*|S|) sinc we are storing n strings of size |S| in hashmap.
    */
    
    
   // Question 2 Overlapping Rectangles
    
    int doOverlap(int L1[], int R1[], int L2[], int R2[]) {
     // to check if the rectangles are actually a line
     if(L1[0]==L2[0] || R1[0] ==R2[0]|| L1[1]==L2[1] || R1[1]==R2[1])
     return false;
    
    // if one rectangle is left of left side of other
    if(R1[0]<L2[0] || R2[0]<L1[0])
    return false;
     // if one rectangle is above the top of other
     if(R1[1]>L2[1] || R2[1]>L1[1])
     return false;
     return true;
}
//T(c)-O(1)
//S(C)- O(1)


//Question 3 count subarrays having product less than k 
     int countSubArrayProductLessThanK(const vector<int>& a, int n, long long k) {
     long long int start=0,end=0,count=0,prod=1;
       while(end<n){
           prod*=a[end];
           while(start<n and prod>=k){
               prod=prod/a[start]; // drop that element
               start++; // slide the window
           }
           if(prod<k)
           count+=end-start+1;
          // +1 because we are also considering individual elements as subarrays
           end++; // increment the size of the window
       }
       return count;
    }
   // T(C)-O(N) since we are traversing the whole array once
   // S(C)-O(1)



// Question 4 Run length encoding
string encode(string src)
{     
  //Your code here 
   string ans = "";
  char prev = src[0];
  int count = 1;
  for(int i=1;i<src.length();i++){
      if(src[i] == prev){
          count++;
      }
      else{
          ans.push_back(prev);
          ans.append(to_string(count));
          count = 1;
          prev = src[i];
      }
  }
  ans.push_back(prev);
  ans.append(to_string(count));
  return ans;
}  
//T(C)-O(N)
//S(C)-O(1)

// Question 7 Distributing M items in a circle of size N starting from K-th position
int Solution::solve(int M, int N, int K) {
    int n= (M+K-1)%N;
    if (n==0){
    return N;
    }
    
    return n;

}


 
