solutions to problems of goldman sachs

//Question 1. print all anagrams together
//solution
vector<vector<string> > Anagrams(vector<string>& string_list) {
        vector<vector<string>> ans;
        unordered_map<string,vector<string> >umap;
        for( int i=0;i<string_list.size(); i++){
            
        
        string s =string_list[i];
        sort(s.begin(),s.end());
        umap[s].push_back(string_list[i]);
        
    }
    for(auto itr=umap.begin(); itr!=umap.end();itr++)
    ans.push_back(itr->second);
    return ans;
    }
    /* 
    T(c)- O(N*|S|*log|S|) where N is the total number of strings and |S| denotes the size of string so |S|log|S| time would be taken for sorting them.
    S(c)-O(N*|S|) sinc we are storing n strings of size |S| in hashmap.
    */
    
    
   // Question 2 Overlapping Rectangles
    
    int doOverlap(int L1[], int R1[], int L2[], int R2[]) {
     // to check if the rectangles are actually a line
     if(L1[0]==L2[0] || R1[0] ==R2[0]|| L1[1]==L2[1] || R1[1]==R2[1])
     return false;
    
    // if one rectangle is left of left side of other
    if(R1[0]<L2[0] || R2[0]<L1[0])
    return false;
     // if one rectangle is above the top of other
     if(R1[1]>L2[1] || R2[1]>L1[1])
     return false;
     return true;
}
//T(c)-O(1)
//S(C)- O(1)


//Question 3 count subarrays having product less than k 
     int countSubArrayProductLessThanK(const vector<int>& a, int n, long long k) {
     long long int start=0,end=0,count=0,prod=1;
       while(end<n){
           prod*=a[end];
           while(start<n and prod>=k){
               prod=prod/a[start]; // drop that element
               start++; // slide the window
           }
           if(prod<k)
           count+=end-start+1;
          // +1 because we are also considering individual elements as subarrays
           end++; // increment the size of the window
       }
       return count;
    }
   // T(C)-O(N) since we are traversing the whole array once
   // S(C)-O(1)



// Question 4 Run length encoding
string encode(string src)
{     
  //Your code here 
   string ans = "";
  char prev = src[0];
  int count = 1;
  for(int i=1;i<src.length();i++){
      if(src[i] == prev){
          count++;
      }
      else{
          ans.push_back(prev);
          ans.append(to_string(count));
          count = 1;
          prev = src[i];
      }
  }
  ans.push_back(prev);
  ans.append(to_string(count));
  return ans;
}  
//T(C)-O(N)
//S(C)-O(1)

// Question 5 Program to find Nth ugly number.

	ull getNthUglyNo(int n) {
	    vector<ull> vec(1,1); // we have added 1 as an ugly number
	    for(int x=0,y=0,z=0; vec.size()!=n;){ // performing the operation since size of vector becomes n
	        ull val= min(min(vec[x]*2,vec[y]*3),vec[z]*5); // multiply 2 3 and 5  with the least value in the vector and select min among those multiples
	        vec.push_back(val); 
	        if(vec.back()==vec[x]*2)
	        x++;
	         if(vec.back()==vec[y]*3)
	        y++;
	         if(vec.back()==vec[z]*5)
	        z++;
	        
	    }
	    return vec.back(); // return the last value i.e nth value of vector
	 
	}
        T(C)-O(N)
        S(C)-O(N)
        

// Question 7 Distributing M items in a circle of size N starting from K-th position
int Solution::solve(int M, int N, int K) {
    int n= (M+K-1)%N;
    if (n==0){
    return N;
    }
    
    return n;

}


// Question 9 Number following a pattern 
 string printMinNumberForPattern(string S){
        // code here 
        // we are using stack bcz it works on LIFO principle and we want to print the output 
       // in reverse order for decreasing sequence.
        stack<int> st;
        string ans ="";
        int num=1;
        for(int i=0;i<S.size();i++){
            char c=S[i];
            if(c=='D'){ // if character is d push it into stack and incr num
                st.push(num++);
                
            }
            else { // if we encounter i it is a breakpoint so print all previous stack values
                st.push(num++);
                while(!st.empty()){
                    char c1= '0'+st.top();
                    ans.push_back(c1);
                    st.pop();
                    
                }
            }
        }
        st.push(num++);
        while(!st.empty()){
            
            char c1= '0'+st.top(); // explicit conversion to char type
            ans.push_back(c1);
            st.pop();
                    
                }
        return ans;
    }
    
    
    // Question 11 Find missing and repeating 
    pair<int,int> findboth(int *arr, int n){ // helper function find two numbers
    int repeating=0;
    int missing=0;
    for(int i=0;i<n;i++){
        int index=abs(arr[i]-1);
        if(arr[index]>0){         // if the element is positive make it negative
        arr[index]=-1*arr[index];
        }
        else{
            repeating=abs(arr[i]); // if it is already negative that means we are encountering it the second time so its repeating
        }
    }
    for(int i=0;i<n;i++){
        if(arr[i]>0){  // if after the whole process an element is still positive that means we didnt reach to its index which means its missing
            missing=i+1;
            
        }
    }
    return { repeating,missing};
}
    int *findTwoElement(int *arr, int n) {
        int* res= new int[2]; // dynamic array
        pair<int,int> ans= findboth(arr,n);
        res[0] =ans.first;
        res[1]=ans.second;
        return res;
        
    }
    T(C)-O(N)
    S(C)-O(1)


// Question 12 Find number of squares in an N*N chessborad

int calcSquaresCount(int n){
   int squareCount = ( (n * (n+1) * (2*n + 1))/6 ); // since this is the formula for sq(1)+sq(2)+sq(3)+.........+sq(n)
   return squareCount;
}

// Question 14 Minimum size subarray sum
(using two pointer approach)
     int minlen=nums.size()+1;
        int sum=0;
        int left=0;
        for(int right=0;right<nums.size();right++){
            sum=sum+nums[right];
            while(sum>=target && left<=right){
                minlen=min(minlen,right-left+1);
                sum-=nums[left++];
            }
        }
        if (minlen==nums.size()+1 )
            return 0;
        else
            return minlen;
    }
    // T(C)-O(N)
    // S(C)-O(N)

 
